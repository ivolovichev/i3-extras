diff -r -u a/include/i3-atoms_NET_SUPPORTED.xmacro.h b/include/i3-atoms_NET_SUPPORTED.xmacro.h
--- a/include/i3-atoms_NET_SUPPORTED.xmacro.h	1970-01-01 03:00:00.000000000 +0300
+++ b/include/i3-atoms_NET_SUPPORTED.xmacro.h	2020-11-24 15:37:25.233093693 +0200
@@ -15,6 +15,7 @@
 xmacro(_NET_WM_WINDOW_TYPE) \
 xmacro(_NET_WM_WINDOW_TYPE_NORMAL) \
 xmacro(_NET_WM_WINDOW_TYPE_DOCK) \
+xmacro(_NET_WM_WINDOW_TYPE_DESKTOP) \
 xmacro(_NET_WM_WINDOW_TYPE_DIALOG) \
 xmacro(_NET_WM_WINDOW_TYPE_UTILITY) \
 xmacro(_NET_WM_WINDOW_TYPE_TOOLBAR) \
diff -r -u a/src/click.c b/src/click.c
--- a/src/click.c	1970-01-01 03:00:00.000000000 +0300
+++ b/src/click.c	2020-11-24 15:35:08.673800919 +0200
@@ -11,6 +11,8 @@
 
 #include <time.h>
 
+extern xcb_window_t desktop_window;
+
 typedef enum { CLICK_BORDER = 0,
                CLICK_DECORATION = 1,
                CLICK_INSIDE = 2 } click_destination_t;
@@ -350,7 +352,12 @@
             return;
         }
 
-        ELOG("Clicked into unknown window?!\n");
+        if(desktop_window != XCB_NONE && event->event == desktop_window) {
+            Con *ws = con_get_workspace(focused);
+            con_focus(ws);
+            return route_click(ws, event, mod_pressed, CLICK_INSIDE);
+        } else
+            ELOG("Clicked into unknown window?!\n");
         xcb_allow_events(conn, XCB_ALLOW_REPLAY_POINTER, event->time);
         xcb_flush(conn);
         return;
diff -r -u a/src/commands.c b/src/commands.c
--- a/src/commands.c	1970-01-01 03:00:00.000000000 +0300
+++ b/src/commands.c	2020-11-24 15:43:02.266880191 +0200
@@ -14,6 +14,8 @@
 #include <stdint.h>
 #include <unistd.h>
 
+extern xcb_window_t desktop_window;
+
 // Macros to make the YAJL API a bit easier to use.
 #define y(x, ...) (cmd_output->json_gen != NULL ? yajl_gen_##x(cmd_output->json_gen, ##__VA_ARGS__) : 0)
 #define ystr(str) (cmd_output->json_gen != NULL ? yajl_gen_string(cmd_output->json_gen, (unsigned char *)str, strlen(str)) : 0)
@@ -1331,6 +1333,13 @@
     Con *ws = con_get_workspace(focused);
     Con *current;
     bool success = false;
+
+    if (strcmp(window_mode, "tiling")==0 && TAILQ_EMPTY(&(ws->nodes_head)) && desktop_window != XCB_NONE){
+        con_focus(ws);
+        success = true;
+        goto end;
+    }
+
     TAILQ_FOREACH (current, &(ws->focus_head), focused) {
         if ((to_floating && current->type != CT_FLOATING_CON) ||
             (!to_floating && current->type == CT_FLOATING_CON))
@@ -1341,6 +1350,7 @@
         break;
     }
 
+    end:
     if (success) {
         cmd_output->needs_tree_render = true;
         ysuccess(true);
diff -r -u a/src/con.c b/src/con.c
--- a/src/con.c	1970-01-01 03:00:00.000000000 +0300
+++ b/src/con.c	2020-11-24 15:35:08.676800882 +0200
@@ -12,6 +12,8 @@
 #include "all.h"
 #include "yajl_utils.h"
 
+extern xcb_window_t desktop_window;
+
 static void con_on_remove_child(Con *con);
 
 /*
@@ -1431,6 +1433,9 @@
         return;
     }
 
+    if (focused->type == CT_WORKSPACE && desktop_window != XCB_NONE)
+        return;
+
     Con *target = con_descend_focused(workspace);
     _con_move_to_con(con, target, true, fix_coordinates, dont_warp, ignore_focus, true);
 }
diff -r -u a/src/handlers.c b/src/handlers.c
--- a/src/handlers.c	1970-01-01 03:00:00.000000000 +0300
+++ b/src/handlers.c	2020-11-24 15:35:08.678800857 +0200
@@ -22,6 +22,8 @@
 int xkb_current_group;
 int shape_base = -1;
 
+extern xcb_window_t desktop_window;
+
 /* After mapping/unmapping windows, a notify event is generated. However, we don’t want it,
    since it’d trigger an infinite loop of switching between the different windows when
    changing workspaces */
@@ -147,6 +149,19 @@
         enter_child = true;
     }
 
+    if(desktop_window != XCB_NONE && event->event == desktop_window){
+        /* This check stops the desktop window from stealing the focus when a floating window
+         * is focused through a command/keybinding but the pointer is still on the desktop window */
+        if (event->detail==XCB_NOTIFY_DETAIL_NONLINEAR){
+            if(config.disable_focus_follows_mouse==false){
+                Con *ws = con_get_workspace(focused);
+                con_focus(ws);
+                tree_render();
+            }
+        } else
+            return;
+    }
+
     /* If we cannot find the container, the user moved their cursor to the root
      * window. In this case and if they used it to a dock, we need to focus the
      * workspace on the correct output. */
diff -r -u a/src/manage.c b/src/manage.c
--- a/src/manage.c	1970-01-01 03:00:00.000000000 +0300
+++ b/src/manage.c	2020-11-24 15:35:08.678800857 +0200
@@ -9,6 +9,8 @@
  */
 #include "all.h"
 
+extern xcb_window_t desktop_window;
+
 /*
  * Match frame and window depth. This is needed because X will refuse to reparent a
  * window whose background is ParentRelative under a window with a different depth.
@@ -235,6 +237,16 @@
     /* read the preferred _NET_WM_WINDOW_TYPE atom */
     cwindow->window_type = xcb_get_preferred_window_type(type_reply);
 
+    /* map _NET_WM_WINDOW_TYPE_DESKTOP windows and receive focus events, but don't manage them */
+    if (xcb_reply_contains_atom(type_reply, A__NET_WM_WINDOW_TYPE_DESKTOP)) {
+        desktop_window = window;
+        xcb_map_window(conn, window);
+        values[0] = XCB_EVENT_MASK_ENTER_WINDOW;
+        xcb_change_window_attributes(conn, window, XCB_CW_EVENT_MASK, values);
+        xcb_flush(conn);
+        goto geom_out;
+    }
+    
     /* Where to start searching for a container that swallows the new one? */
     Con *search_at = croot;
 
diff -r -u a/src/tree.c b/src/tree.c
--- a/src/tree.c	1970-01-01 03:00:00.000000000 +0300
+++ b/src/tree.c	2020-11-24 15:35:08.679800844 +0200
@@ -12,6 +12,8 @@
 struct Con *croot;
 struct Con *focused;
 
+xcb_window_t desktop_window = XCB_NONE;
+
 struct all_cons_head all_cons = TAILQ_HEAD_INITIALIZER(all_cons);
 
 /*
diff -r -u a/src/x.c b/src/x.c
--- a/src/x.c	1970-01-01 03:00:00.000000000 +0300
+++ b/src/x.c	2020-11-24 15:35:08.679800844 +0200
@@ -18,6 +18,7 @@
 
 /* Stores the X11 window ID of the currently focused window */
 xcb_window_t focused_id = XCB_NONE;
+extern xcb_window_t desktop_window;
 
 /* Because 'focused_id' might be reset to force input focus, we separately keep
  * track of the X11 window ID to be able to always tell whether the focused
@@ -492,6 +493,8 @@
     /* find out which colors to use */
     if (con->urgent)
         p->color = &config.client.urgent;
+    else if (focused->type==CT_WORKSPACE && desktop_window != XCB_NONE)
+        p->color = &config.client.focused_inactive;
     else if (con == focused || con_inside_focused(con))
         p->color = &config.client.focused;
     else if (con == TAILQ_FIRST(&(parent->focus_head)))
@@ -1275,6 +1278,12 @@
     if (focused->window != NULL)
         to_focus = focused->window->id;
 
+    if(focused->type == CT_WORKSPACE && desktop_window != XCB_NONE) {
+        to_focus = desktop_window;
+        /* assume that the desktop window is mapped */
+        focused->mapped = true;
+    }
+    
     if (focused_id != to_focus) {
         if (!focused->mapped) {
             DLOG("Not updating focus (to %p / %s), focused window is not mapped.\n", focused, focused->name);
